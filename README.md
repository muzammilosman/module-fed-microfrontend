# Microfrontends

When there are frontend modules which need to be worked upon by different teams and would be better off staying in a mono-repo then we may prefer micro-frontends instead of the packages approach.

### Webpack Module Federation

*STEPS*

- Designate one app as host and one as the remote
- Decide which files in the remote needs to be accessed by other modules
- Set up module federation plugin to expose the files
- In the host, set up module federation to import the files from the remote
- In the host, refactor the entry point to load asynchronously


### Module federation plugin

```jsx
// webpack.config.js (remote)
// plugins other than module federation are omitted

module.exports = {
	devServer: {
		port: 8081
	}
	plugins: [
		new ModuleFederationPlugin({
			name: 'products',
			filename: 'remoteEntry.js'
			exposes: {
				'./ProductsIndex': './src/index'	
			},
			shared: ['faker']
		})
	]
}

// (host)

module.exports = {
	devServer: {
		port: 8081
	}
	plugins: [
		new ModuleFederationPlugin({
			name: 'container',
			remotes: {
				products: 'products@http://localhost:8081/remoteEntry.js'
			}
		})
	]
}

```

- The container (host) will build the main.js which can import `products/ProductsIndex` . This will import the `index.js` file from the remote which is being exposed in the `webpack.config.js` file using module federation plugin.
- The remotes in the `container` app says where to fetch the remote application. `products` is the key which is used for the imports in the container. For example

```jsx
//bootstrap.js (container)

import 'products/ProductsIndex'
```

- Make sure the remotes are up and running before the import statement in the container gets executed.
- The `index.html` file which is generated by the build of remotes will only be useful in case of development. Ultimately the `index.html` of the container will be the only one loaded in browser.

### **Using shared modules**

- The browser would fetch dependencies multiple times when there are duplicates of the same dependency in multiple frontends.
- To avoid this, we declare the common dependencies in the `webpack.config.js` file in the remote applications.
- `shared: ['faker']` will make sure if the dependency named `faker` is already cached in the container application
- In addition to this, we may have to move the import statement to a `bootstrap.js` file as it would be imported **asynchronously**

```jsx
// bootstrap.js (remotes)

import faker from 'faker'

*/ {code that goes here} */

// index.js

import('./bootstrap')
```

- Note: If remotes require different versions of a dependency, then they can be manually installed in the required remote frontend. This will bypass the shared module feature

### Advantages

- Teams can build frontend applications in isolation